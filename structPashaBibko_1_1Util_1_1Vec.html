<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pasha Bibko Util Library: Vec&lt; len, Ty &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Pasha Bibko Util Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structPashaBibko_1_1Util_1_1Vec.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structPashaBibko_1_1Util_1_1Vec-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Vec&lt; len, Ty &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Mathmatical vector class.  
 <a href="structPashaBibko_1_1Util_1_1Vec.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Vec_8h_source.html">Vec.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Vec&lt; len, Ty &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structPashaBibko_1_1Util_1_1Vec__inherit__graph.png" border="0" usemap="#aVec_3_01len_00_01Ty_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aVec_3_01len_00_01Ty_01_4_inherit__map" id="aVec_3_01len_00_01Ty_01_4_inherit__map">
<area shape="rect" title="Mathmatical vector class." alt="" coords="36,79,153,104"/>
<area shape="rect" title=" " alt="" coords="5,5,184,31"/>
<area shape="poly" title=" " alt="" coords="97,44,97,79,92,79,92,44"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Vec&lt; len, Ty &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structPashaBibko_1_1Util_1_1Vec__coll__graph.png" border="0" usemap="#aVec_3_01len_00_01Ty_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aVec_3_01len_00_01Ty_01_4_coll__map" id="aVec_3_01len_00_01Ty_01_4_coll__map">
<area shape="rect" title="Mathmatical vector class." alt="" coords="36,79,153,104"/>
<area shape="rect" title=" " alt="" coords="5,5,184,31"/>
<area shape="poly" title=" " alt="" coords="97,44,97,79,92,79,92,44"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaf06ec283f7b99e1e6c2a1fbe247cda3" id="r_aaf06ec283f7b99e1e6c2a1fbe247cda3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a>  = std::enable_if_t&lt;std::is_default_constructible_v&lt;Ty&gt;&gt;&gt; </td></tr>
<tr class="memitem:aaf06ec283f7b99e1e6c2a1fbe247cda3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">Vec</a> ()</td></tr>
<tr class="memdesc:aaf06ec283f7b99e1e6c2a1fbe247cda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor which default constructs all items.  <br /></td></tr>
<tr class="separator:aaf06ec283f7b99e1e6c2a1fbe247cda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfeebeba5d6508569826583d87a9594" id="r_acbfeebeba5d6508569826583d87a9594"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#acbfeebeba5d6508569826583d87a9594">Vec</a> (<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &amp;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">value</a>)</td></tr>
<tr class="memdesc:acbfeebeba5d6508569826583d87a9594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to create each item in the vector with a given value.  <br /></td></tr>
<tr class="separator:acbfeebeba5d6508569826583d87a9594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e7c008d8836bc8ac129d07d45b8c52" id="r_a64e7c008d8836bc8ac129d07d45b8c52"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires Internal::AllSameType&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Args...&gt; &amp;&amp; (sizeof...(<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Args</a>) == <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>)</td></tr>
<tr class="memitem:a64e7c008d8836bc8ac129d07d45b8c52"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#a64e7c008d8836bc8ac129d07d45b8c52">Vec</a> (<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Args</a> &amp;&amp;... <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">args</a>)</td></tr>
<tr class="memdesc:a64e7c008d8836bc8ac129d07d45b8c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector with a given value for each item.  <br /></td></tr>
<tr class="separator:a64e7c008d8836bc8ac129d07d45b8c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1bb4eeedea285817ec306371109012" id="r_a0b1bb4eeedea285817ec306371109012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#a0b1bb4eeedea285817ec306371109012">operator[]</a> (std::size_t index)</td></tr>
<tr class="memdesc:a0b1bb4eeedea285817ec306371109012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the item at that index.  <br /></td></tr>
<tr class="separator:a0b1bb4eeedea285817ec306371109012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c45fda4e56f618835adc1b9e8458b9" id="r_ad9c45fda4e56f618835adc1b9e8458b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#ad9c45fda4e56f618835adc1b9e8458b9">begin</a> () <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">noexcept</a></td></tr>
<tr class="memdesc:ad9c45fda4e56f618835adc1b9e8458b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the beginning of the array.  <br /></td></tr>
<tr class="separator:ad9c45fda4e56f618835adc1b9e8458b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889d89b714a7fbe84e3e4d27ff42f22f" id="r_a889d89b714a7fbe84e3e4d27ff42f22f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#a889d89b714a7fbe84e3e4d27ff42f22f">end</a> ()</td></tr>
<tr class="memdesc:a889d89b714a7fbe84e3e4d27ff42f22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the end of the vector.  <br /></td></tr>
<tr class="separator:a889d89b714a7fbe84e3e4d27ff42f22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77adb2f2e88d50bf4426df7dfa932735" id="r_a77adb2f2e88d50bf4426df7dfa932735"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanAdd&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::AddResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</td></tr>
<tr class="memitem:a77adb2f2e88d50bf4426df7dfa932735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#a77adb2f2e88d50bf4426df7dfa932735">operator+=</a> (<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">other</a>)</td></tr>
<tr class="memdesc:a77adb2f2e88d50bf4426df7dfa932735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another vector of the same size to itself.  <br /></td></tr>
<tr class="separator:a77adb2f2e88d50bf4426df7dfa932735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c399b44ef826b50d2364d6e96bddfd" id="r_a39c399b44ef826b50d2364d6e96bddfd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanSub&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::SubResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</td></tr>
<tr class="memitem:a39c399b44ef826b50d2364d6e96bddfd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#a39c399b44ef826b50d2364d6e96bddfd">operator-=</a> (<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">other</a>)</td></tr>
<tr class="memdesc:a39c399b44ef826b50d2364d6e96bddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts another vector of the same size to itself.  <br /></td></tr>
<tr class="separator:a39c399b44ef826b50d2364d6e96bddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50668875736df8f04cce5656da96d4ad" id="r_a50668875736df8f04cce5656da96d4ad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanMul&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::MulResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</td></tr>
<tr class="memitem:a50668875736df8f04cce5656da96d4ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#a50668875736df8f04cce5656da96d4ad">operator*=</a> (<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">other</a>)</td></tr>
<tr class="memdesc:a50668875736df8f04cce5656da96d4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies another vector of the same size to itself.  <br /></td></tr>
<tr class="separator:a50668875736df8f04cce5656da96d4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b12d76ff37ba36843029796835ad3" id="r_a202b12d76ff37ba36843029796835ad3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanDiv&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::DivResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</td></tr>
<tr class="memitem:a202b12d76ff37ba36843029796835ad3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#a202b12d76ff37ba36843029796835ad3">operator/=</a> (<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">other</a>)</td></tr>
<tr class="memdesc:a202b12d76ff37ba36843029796835ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides another vector of the same size to itself.  <br /></td></tr>
<tr class="separator:a202b12d76ff37ba36843029796835ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">Ty</a>&gt;<br />
requires (<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">len</a> != 0 &amp;&amp; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">len</a> != 1) &amp;&amp; std::is_copy_constructible_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">Ty</a>&gt;<br />
struct PashaBibko::Util::Vec&lt; len, Ty &gt;</div><p>Mathmatical vector class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">len</td><td>The length of the array, cannot be 0 or 1. </td></tr>
    <tr><td class="paramname">Ty</td><td>The type that the vector contains must be copyable.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html" title="Mathmatical vector class.">Vec</a></code> class is a fixed-size, strongly-typed mathematical vector implementation that supports compile-time size checking and type constraints. It is designed for mathematical operations and performance-critical applications where a fixed size and no dynamic memory allocation are desired.</p>
<p>For convenience whilst using there are also multiple typedefs for easier recognition of common <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html" title="Mathmatical vector class.">Vec</a> types. For vectors between size of 2 and 4 you are able to write Vec2&lt;Ty&gt; / Vec3&lt;Ty&gt; / Vec4&lt;Ty&gt; where Ty is the type that you want the vector to contain. If no type is provided it will default to float.</p>
<p>Combined with this, there are also typedefs of these lengths with the types. Below are the Vec2 types but the number can be changed to work with Vec3 and Vec4.</p><ul>
<li>short = Vec2s</li>
<li>int = Vec2i</li>
<li>unsigned int = Vec2u</li>
<li>long = Vec2l</li>
<li>double = Vec2d</li>
</ul>
<p>For further convenience vectors between the lengths of 2 and 4 allow access to their members via letters:</p><ul>
<li>x = data[0]</li>
<li>y = data[1]</li>
<li>z = data[2]</li>
<li>w = data[3]</li>
</ul>
<p>If you are working with colours you are also able to use those letters (only available on Vec3 and Vec4):</p><ul>
<li>r = data[0]</li>
<li>g = data[1]</li>
<li>b = data[2]</li>
<li>a = data[3]</li>
</ul>
<p>Letters are only availble if the vector is already that long, for example: Vec2 only has access to x and y as it is only 2 elements long.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a 3D vector with all elements default-initialized to 0</span></div>
<div class="line">    <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">Vec3</a> <a class="code hl_function" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">a</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a vector where all elements are set to 5.0f</span></div>
<div class="line">    <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">Vec3</a> <a class="code hl_function" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">b</a>(5.0f);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a vector from individual values</span></div>
<div class="line">    <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">Vec3</a> <a class="code hl_function" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">c</a>(1.0f, 2.0f, 3.0f);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access and modify an element</span></div>
<div class="line">    <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">c</a>.x = 10.0f;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Iterate over vector elements</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">float</span> <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">value</a> : <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">c</a>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">value</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add two vectors</span></div>
<div class="line">    <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">c</a> += <a class="code hl_function" href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">b</a>; <span class="comment">// element-wise addition</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print result</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">float</span> <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">value</a> : <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">c</a>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <a class="code hl_struct" href="structPashaBibko_1_1Util_1_1Vec.html">value</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructPashaBibko_1_1Util_1_1Vec_html"><div class="ttname"><a href="structPashaBibko_1_1Util_1_1Vec.html">PashaBibko::Util::Vec</a></div><div class="ttdoc">Mathmatical vector class.</div><div class="ttdef"><b>Definition</b> Vec.h:216</div></div>
<div class="ttc" id="astructPashaBibko_1_1Util_1_1Vec_html_aaf06ec283f7b99e1e6c2a1fbe247cda3"><div class="ttname"><a href="structPashaBibko_1_1Util_1_1Vec.html#aaf06ec283f7b99e1e6c2a1fbe247cda3">PashaBibko::Util::Vec::Vec</a></div><div class="ttdeci">Vec()</div><div class="ttdoc">Default constructor which default constructs all items.</div><div class="ttdef"><b>Definition</b> Vec.h:224</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaf06ec283f7b99e1e6c2a1fbe247cda3" name="aaf06ec283f7b99e1e6c2a1fbe247cda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf06ec283f7b99e1e6c2a1fbe247cda3">&#9670;&#160;</a></span>Vec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a>  = std::enable_if_t&lt;std::is_default_constructible_v&lt;Ty&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor which default constructs all items. </p>
<p>Will only be available if Ty has a default constructor to avoid compile-time errors. </p>

</div>
</div>
<a id="acbfeebeba5d6508569826583d87a9594" name="acbfeebeba5d6508569826583d87a9594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfeebeba5d6508569826583d87a9594">&#9670;&#160;</a></span>Vec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to create each item in the vector with a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value that will be copied to all values within the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64e7c008d8836bc8ac129d07d45b8c52" name="a64e7c008d8836bc8ac129d07d45b8c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e7c008d8836bc8ac129d07d45b8c52">&#9670;&#160;</a></span>Vec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires Internal::AllSameType&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Args...&gt; &amp;&amp; (sizeof...(<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Args</a>) == <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector with a given value for each item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments that will be copied to the contents of the vector.</td></tr>
  </table>
  </dd>
</dl>
<p>Requires all arguments to be the same type as Ty and have the same length as the array or will have a compile-time error. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9c45fda4e56f618835adc1b9e8458b9" name="ad9c45fda4e56f618835adc1b9e8458b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c45fda4e56f618835adc1b9e8458b9">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> * begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the beginning of the array. </p>
<p>Used by C++ to allow the data type to be iterated over by a range for loop. </p>

</div>
</div>
<a id="a889d89b714a7fbe84e3e4d27ff42f22f" name="a889d89b714a7fbe84e3e4d27ff42f22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889d89b714a7fbe84e3e4d27ff42f22f">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> * end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the end of the vector. </p>
<p>Used by C++ to allow the data type to be iterated over by a range for loop. </p>

</div>
</div>
<a id="a50668875736df8f04cce5656da96d4ad" name="a50668875736df8f04cce5656da96d4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50668875736df8f04cce5656da96d4ad">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanMul&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::MulResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">operator</a>*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies another vector of the same size to itself. </p>
<p>Requires Ty to be able to be multipled by OtherTy, otherwise it will not compile and the result type to be the same as Ty. </p>

</div>
</div>
<a id="a77adb2f2e88d50bf4426df7dfa932735" name="a77adb2f2e88d50bf4426df7dfa932735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77adb2f2e88d50bf4426df7dfa932735">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanAdd&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::AddResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">operator</a>+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds another vector of the same size to itself. </p>
<p>Requires OtherTy to be able to be added to Ty, otherwise it will not compile and the result type to be the same as Ty. </p>

</div>
</div>
<a id="a39c399b44ef826b50d2364d6e96bddfd" name="a39c399b44ef826b50d2364d6e96bddfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c399b44ef826b50d2364d6e96bddfd">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanSub&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::SubResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">operator</a>-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts another vector of the same size to itself. </p>
<p>Requires OtherTy to be able to be subtracted from Ty, otherwise it will not compile and the result type to be the same as Ty. </p>

</div>
</div>
<a id="a202b12d76ff37ba36843029796835ad3" name="a202b12d76ff37ba36843029796835ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202b12d76ff37ba36843029796835ad3">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; <br />
requires Internal::CanDiv&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, Internal::DivResultT&lt;<a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a>&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a> &amp; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">operator</a>/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">const</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a>&lt; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">len</a>, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">OtherTy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides another vector of the same size to itself. </p>
<p>Requires Ty to be able to be divided by OtherTy, otherwise it will not compile and the result type to be the same as Ty. </p>

</div>
</div>
<a id="a0b1bb4eeedea285817ec306371109012" name="a0b1bb4eeedea285817ec306371109012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1bb4eeedea285817ec306371109012">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t len, <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">typename</a> <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Ty</a> &amp; <a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">operator</a>[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the item at that index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index that it will find the item of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check if the index is within the bounds of the vector. Accessing elements not within the bounds is classified as UB. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>classes/<a class="el" href="Vec_8h_source.html">Vec.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacePashaBibko.html">PashaBibko</a></li><li class="navelem"><a class="el" href="namespacePashaBibko_1_1Util.html">Util</a></li><li class="navelem"><a class="el" href="structPashaBibko_1_1Util_1_1Vec.html">Vec</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
